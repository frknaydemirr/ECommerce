ViewComponent, Controller bağımsız, kendi içinde hem veri işleme (C# kodu) hem de görünüm
(Razor view) mantığını taşıyabilen küçük, 
yeniden kullanılabilir bir bileşendir.

✅ Ne işe yarar?

Yeniden kullanılabilirlik sağlar

Mesela: “Son Haberler”, “Sepet Özeti”, “Kategoriler Menüsü” gibi sayfanın birçok yerinde 
kullanılan parçaları tek bir yerde yazar ve her yerde çağırabilirsiniz.

Controller bağımsızdır

Normal PartialView’ler genelde Controller üzerinden veri alır. Ama ViewComponent kendi Invoke 
metodu ile istediği veriyi kendisi alır.

Daha test edilebilir ve modülerdir

Çünkü hem C# kodu hem de View dosyası birlikte gelir. Yani küçük bir mini-MVC gibidir.

Asenkron çalışabilir

InvokeAsync metodu ile async/await kullanabilirsiniz. Bu, performans açısından faydalıdır.

View içinde çağırılır

@Component.InvokeAsync("LatestNews")

Generic Repository Pattern:
Generic Repository Pattern, yazılımda data access (veri erişim) katmanını soyutlamak
için kullanılan bir tasarım desenidir.
Amacı şudur:

Her entity için ayrı ayrı repository yazmak yerine,

Ortak (generic) bir repository oluşturup tekrar eden 
CRUD (Create, Read, Update, Delete) işlemlerini tek noktadan yönetmek.
public class ProductRepository
{
    public void Add(Product product) { ... }
    public void Update(Product product) { ... }
    public void Delete(Product product) { ... }
    public Product GetById(int id) { ... }
    public IEnumerable<Product> GetAll() { ... }
}

🛠 Generic Repository

Bunun yerine generic bir interface tanımlarsın:

public interface IGenericRepository<T> where T : class
{
    IEnumerable<T> GetAll();
    T GetById(int id);
    void Add(T entity);
    void Update(T entity);
    void Delete(T entity);
}
Ve bir generic implementation:
public class GenericRepository<T> : IGenericRepository<T> where T : class
{
    private readonly DbContext _context;
    private readonly DbSet<T> _dbSet;

    public GenericRepository(DbContext context)
    {
        _context = context;
        _dbSet = _context.Set<T>();
    }

    public IEnumerable<T> GetAll()
    {
        return _dbSet.ToList();
    }

    public T GetById(int id)
    {
        return _dbSet.Find(id);
    }

    public void Add(T entity)
    {
        _dbSet.Add(entity);
    }

    public void Update(T entity)
    {
        _dbSet.Update(entity);
    }

    public void Delete(T entity)
    {
        _dbSet.Remove(entity);
    }
}
Artık ProductRepository, CategoryRepository yazmana gerek yok:
-> artık her bir data için ayrı ayrı repository yazmaya gerek yok:
var productRepo = new GenericRepository<Product>(dbContext);
var allProducts = productRepo.GetAll();

var categoryRepo = new GenericRepository<Category>(dbContext);
var categories = categoryRepo.GetAll();
Kısaca:
Generic Repository Pattern = Tekrarlayan CRUD kodlarını tek bir generic yapı ile çözmek.
🎯 Avantajları

Kod tekrarını azaltır.

CRUD işlemleri tek yerde toplanır.

Tüm entity’ler için aynı mantığı uygular.

Test edilebilirliği artırır.

Code Review (kod inceleme), yazılım geliştirme sürecinde bir geliştiricinin yazdığı kodun,
başka geliştiriciler tarafından gözden geçirilmesi sürecidir.

Amaç sadece “hata bulmak” değil, aynı zamanda:

Kodun kalitesini artırmak

Standartlara uygunluğu sağlamak

Bakımı kolay ve okunabilir hale getirmek

Takım içinde bilgi paylaşımı yapmak

Potansiyel bug’ları erken yakalamak

🔎 Code Review Süreci Nasıl İşler?

Bir geliştirici yeni özellik ya da düzeltme için kod yazar.

Kod, genellikle Pull Request (PR) ya da Merge Request (MR) ile ana branch’e 
eklenmek üzere açılır.

Başka takım arkadaşları kodu inceler:

Kod okunabilir mi?

Gereksiz karmaşıklık var mı?

Performans sorunları olabilir mi?

Güvenlik açıkları var mı?

Proje standartlarına uygun mu?

Gerekirse yorumlar yapılır, düzeltmeler istenir.

Son onaydan sonra kod merge edilir.

🎯 Code Review’un Faydaları

Hata sayısını azaltır (özellikle production’a çıkmadan önce).

Kodun okunabilirliğini artırır.

Takım içinde bilgi paylaşımı sağlar (junior → senior öğrenir).

Best practice yayılımına yardımcı olur.

Tek kişinin yazdığı kod yerine takımın ortak sorumluluğunda olur.


Sessions Yapısı:
1. Session (Oturum) Nedir?

Session, bir kullanıcının web sitesiyle olan etkileşimi boyunca sunucu tarafında tutulan
geçici veriler anlamına gelir.

Örneğin; bir kullanıcı siteye giriş yaptı → bu bilgiyi her request’te tekrar
sorgulamamak için session’da saklarsın.

Tarayıcı ile sunucu arasındaki köprü ise cookie’dir. Session ID cookie içine 
yazılır, kullanıcı her istek yaptığında
bu ID gönderilir, sunucu da doğru session verilerini bulur.
2. Neden Kullanırız?

Kullanıcıya özel veri saklamak için:

Giriş yapan kullanıcının bilgileri

Sepete eklenen ürünler

Dil/tema tercihleri

Stateless HTTP’yi stateful hale getirmek için:
HTTP normalde "stateless"tir yani her istek bağımsızdır.
Session sayesinde “bu istek aynı kullanıcıya ait” diyebilirsin.
👉 Normalde session içine sadece string veya byte[] kaydedebilirsin.
Ama senin yazdığın SetJson ve GetJson metotları sayesinde herhangi 
bir nesneyi JSON’a çevirip saklayabiliyorsun.
🔑 1. Kullanıcının oturuma otomatik girmesi

Kullanıcı giriş yaptıysa, genellikle Authentication Cookie (kimlik doğrulama çerezi) oluşturulur.

Bu cookie’de kullanıcıya ait token / ticket saklanır.

Tarayıcıyı kapatıp açtığında, cookie hâlâ geçerliyse → kullanıcı tekrar giriş yapmak zorunda kalmaz.

ASP.NET Core’da bu iş genelde Identity / Authentication middleware tarafından yapılır (senin Session değil).

👉 Yani “kullanıcının oturuma otomatik girmesi” → cookie sayesinde olur.

🛒 2. Sepetteki ürünlerin kalması

Burada iki yaklaşım var:

a) Session ile tutarsan

Senin yazdığın SetJson / GetJson metotlarıyla session’da ürünleri saklarsın.

Ama session sunucu tarafında saklanır ve session cookie’si (SessionId) tarayıcı kapanınca çoğu zaman silinir.

Dolayısıyla tarayıcı kapanıp açıldığında sepet boş gelebilir (IdleTimeout dolmadan bile olabilir).

b) Cookie ile tutarsan

Ürünleri JSON olarak cookie’ye yazabilirsin.

Cookie’nin expires süresi ne kadarsa (ör. 7 gün), tarayıcı kapansa da ürünler durur.

Kullanıcı siteye tekrar girdiğinde → cookie okunur → sepete doldurulur.

👉 Yani “sepette ürünlerin kalması” da cookie ile yapılır (veya DB’de kullanıcıya bağlı sepet kaydı tutarak).